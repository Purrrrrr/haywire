<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>libghthash: ght_hash_table.h File Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.2 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a></div>
<div class="nav">
<a class="el" href="dir_000000.html">src</a></div>
<h1>ght_hash_table.h File Reference</h1><code>#include &lt;stdlib.h&gt;</code><br>

<p>
<a href="ght__hash__table_8h-source.html">Go to the source code of this file.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a0" doxytag="ght_hash_table.h::GHT_HEURISTICS_NONE"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>GHT_HEURISTICS_NONE</b>&nbsp;&nbsp;&nbsp;0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a1" doxytag="ght_hash_table.h::GHT_HEURISTICS_TRANSPOSE"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>GHT_HEURISTICS_TRANSPOSE</b>&nbsp;&nbsp;&nbsp;1</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a2" doxytag="ght_hash_table.h::GHT_HEURISTICS_MOVE_TO_FRONT"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>GHT_HEURISTICS_MOVE_TO_FRONT</b>&nbsp;&nbsp;&nbsp;2</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a3" doxytag="ght_hash_table.h::GHT_AUTOMATIC_REHASH"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>GHT_AUTOMATIC_REHASH</b>&nbsp;&nbsp;&nbsp;4</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a4" doxytag="ght_hash_table.h::TRUE"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>TRUE</b>&nbsp;&nbsp;&nbsp;1</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a5" doxytag="ght_hash_table.h::FALSE"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>FALSE</b>&nbsp;&nbsp;&nbsp;0</td></tr>

<tr><td colspan="2"><br><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ght__hash__table_8h.html#a6">ght_uint32_t</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="structs__hash__key.html">s_hash_key</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ght__hash__table_8h.html#a7">ght_hash_key_t</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a8" doxytag="ght_hash_table.h::ght_hash_entry_t"></a>
typedef s_hash_entry&nbsp;</td><td class="memItemRight" valign="bottom"><b>ght_hash_entry_t</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="ght__hash__table_8h.html#a6">ght_uint32_t</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ght__hash__table_8h.html#a9">ght_fn_hash_t</a> )(<a class="el" href="structs__hash__key.html">ght_hash_key_t</a> *p_key)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef void *(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ght__hash__table_8h.html#a10">ght_fn_alloc_t</a> )(size_t size)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ght__hash__table_8h.html#a11">ght_fn_free_t</a> )(void *ptr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a12" doxytag="ght_hash_table.h::ght_fn_bucket_free_callback_t"></a>
typedef void(*&nbsp;</td><td class="memItemRight" valign="bottom"><b>ght_fn_bucket_free_callback_t</b> )(void *data, void *key)</td></tr>

<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structght__hash__table__t.html">ght_hash_table_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ght__hash__table_8h.html#a13">ght_create</a> (unsigned int i_size)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ght__hash__table_8h.html#a14">ght_set_alloc</a> (<a class="el" href="structght__hash__table__t.html">ght_hash_table_t</a> *p_ht, <a class="el" href="ght__hash__table_8h.html#a10">ght_fn_alloc_t</a> fn_alloc, <a class="el" href="ght__hash__table_8h.html#a11">ght_fn_free_t</a> fn_free)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ght__hash__table_8h.html#a15">ght_set_hash</a> (<a class="el" href="structght__hash__table__t.html">ght_hash_table_t</a> *p_ht, <a class="el" href="ght__hash__table_8h.html#a9">ght_fn_hash_t</a> fn_hash)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ght__hash__table_8h.html#a16">ght_set_heuristics</a> (<a class="el" href="structght__hash__table__t.html">ght_hash_table_t</a> *p_ht, int i_heuristics)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ght__hash__table_8h.html#a17">ght_set_rehash</a> (<a class="el" href="structght__hash__table__t.html">ght_hash_table_t</a> *p_ht, int b_rehash)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ght__hash__table_8h.html#a18">ght_set_bounded_buckets</a> (<a class="el" href="structght__hash__table__t.html">ght_hash_table_t</a> *p_ht, unsigned int limit, ght_fn_bucket_free_callback_t fn)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ght__hash__table_8h.html#a19">ght_size</a> (<a class="el" href="structght__hash__table__t.html">ght_hash_table_t</a> *p_ht)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ght__hash__table_8h.html#a20">ght_table_size</a> (<a class="el" href="structght__hash__table__t.html">ght_hash_table_t</a> *p_ht)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ght__hash__table_8h.html#a21">ght_insert</a> (<a class="el" href="structght__hash__table__t.html">ght_hash_table_t</a> *p_ht, void *p_entry_data, unsigned int i_key_size, void *p_key_data)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ght__hash__table_8h.html#a22">ght_replace</a> (<a class="el" href="structght__hash__table__t.html">ght_hash_table_t</a> *p_ht, void *p_entry_data, unsigned int i_key_size, void *p_key_data)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ght__hash__table_8h.html#a23">ght_get</a> (<a class="el" href="structght__hash__table__t.html">ght_hash_table_t</a> *p_ht, unsigned int i_key_size, void *p_key_data)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ght__hash__table_8h.html#a24">ght_remove</a> (<a class="el" href="structght__hash__table__t.html">ght_hash_table_t</a> *p_ht, unsigned int i_key_size, void *p_key_data)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ght__hash__table_8h.html#a25">ght_first</a> (<a class="el" href="structght__hash__table__t.html">ght_hash_table_t</a> *p_ht, ght_iterator_t *p_iterator, void **pp_key)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ght__hash__table_8h.html#a26">ght_next</a> (<a class="el" href="structght__hash__table__t.html">ght_hash_table_t</a> *p_ht, ght_iterator_t *p_iterator, void **pp_key)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ght__hash__table_8h.html#a27">ght_rehash</a> (<a class="el" href="structght__hash__table__t.html">ght_hash_table_t</a> *p_ht, unsigned int i_size)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ght__hash__table_8h.html#a28">ght_finalize</a> (<a class="el" href="structght__hash__table__t.html">ght_hash_table_t</a> *p_ht)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="ght__hash__table_8h.html#a6">ght_uint32_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ght__hash__table_8h.html#a29">ght_one_at_a_time_hash</a> (<a class="el" href="structs__hash__key.html">ght_hash_key_t</a> *p_key)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="ght__hash__table_8h.html#a6">ght_uint32_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ght__hash__table_8h.html#a30">ght_rotating_hash</a> (<a class="el" href="structs__hash__key.html">ght_hash_key_t</a> *p_key)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="ght__hash__table_8h.html#a6">ght_uint32_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="ght__hash__table_8h.html#a31">ght_crc_hash</a> (<a class="el" href="structs__hash__key.html">ght_hash_key_t</a> *p_key)</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
libghthash is a generic hash table used for storing arbitrary data.<p>
Libghthash really stores pointers to data - the hash table knows nothing about the actual type of the data.<p>
A simple example to get started can be found in the <code>example/simple.c</code> file found in the distribution. <code>hash_test.c</code> provides a more comlpete example.<p>
Some basic properties of the hash table are:<p>
<ul>
<li>Both the data stored and the keys are of void type, which means that you can store any kind of data.</li></ul>
<p>
<ul>
<li>The only functions you probably will need to start is:<ul>
<li><a class="el" href="ght__hash__table_8h.html#a13">ght_create()</a>, which creates a new hash table.</li><li><a class="el" href="ght__hash__table_8h.html#a21">ght_insert()</a>, which inserts a new entry into a table.</li><li><a class="el" href="ght__hash__table_8h.html#a23">ght_get()</a>, which searches for an entry.</li><li><a class="el" href="ght__hash__table_8h.html#a24">ght_remove()</a>, which removes and entry.</li><li><a class="el" href="ght__hash__table_8h.html#a28">ght_finalize()</a>, which destroys a hash table.</li></ul>
</li></ul>
<p>
<ul>
<li>Inserting entries is done without first creating a key, i.e. you insert with the data, the datasize, the key and the key size directly.</li></ul>
<p>
<ul>
<li>The hash table copies the key data when inserting new entries. This means that you should <em>not</em> malloc() the key before inserting a new entry. </li></ul>
<hr><h2>Typedef Documentation</h2>
<a class="anchor" name="a10" doxytag="ght_hash_table.h::ght_fn_alloc_t"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">typedef void*(* <a class="el" href="ght__hash__table_8h.html#a10">ght_fn_alloc_t</a>)(size_t size)          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Definition of the allocation function pointers. This is simply the same definition as <code>malloc()</code>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>the size to allocate. This will always be <code>sizeof(ght_hash_entry_t) + key_size</code>.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>a pointer to the allocated region, or NULL if the allocation failed. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a11" doxytag="ght_hash_table.h::ght_fn_free_t"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">typedef void(* <a class="el" href="ght__hash__table_8h.html#a11">ght_fn_free_t</a>)(void *ptr)          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Definition of the deallocation function pointers. This is simply the same definition as <code>free()</code>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ptr</em>&nbsp;</td><td>a pointer to the region to free. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a9" doxytag="ght_hash_table.h::ght_fn_hash_t"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">typedef <a class="el" href="ght__hash__table_8h.html#a6">ght_uint32_t</a>(* <a class="el" href="ght__hash__table_8h.html#a9">ght_fn_hash_t</a>)(<a class="el" href="structs__hash__key.html">ght_hash_key_t</a> *p_key)          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Definition of the hash function pointers. <code>ght_fn_hash_t</code> should be used when implementing new hash functions. Look at the supplied hash functions, like <code><a class="el" href="ght__hash__table_8h.html#a29">ght_one_at_a_time_hash()</a></code>, for examples of hash functions.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>p_key</em>&nbsp;</td><td>the key to calculate the hash value for.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>a 32 bit hash value.</dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><code><a class="el" href="ght__hash__table_8h.html#a29">ght_one_at_a_time_hash()</a></code>, <code><a class="el" href="ght__hash__table_8h.html#a30">ght_rotating_hash()</a></code>, <code><a class="el" href="ght__hash__table_8h.html#a31">ght_crc_hash()</a></code> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a7" doxytag="ght_hash_table.h::ght_hash_key_t"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">typedef struct <a class="el" href="structs__hash__key.html">s_hash_key</a>  <a class="el" href="structs__hash__key.html">ght_hash_key_t</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The structure for hash keys. You should not care about this structure unless you plan to write your own hash functions.     </td>
  </tr>
</table>
<a class="anchor" name="a6" doxytag="ght_hash_table.h::ght_uint32_t"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">typedef unsigned int <a class="el" href="ght__hash__table_8h.html#a6">ght_uint32_t</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
unsigned 32 bit integer.     </td>
  </tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="a31" doxytag="ght_hash_table.h::ght_crc_hash"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="ght__hash__table_8h.html#a6">ght_uint32_t</a> ght_crc_hash           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structs__hash__key.html">ght_hash_key_t</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>p_key</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
CRC32 hash. CRC32 hash is a good hash function. This came from Dru Lemley &lt;<a href="mailto:spambait@lemley.net">spambait@lemley.net</a>&gt;.<p>
<dl compact><dt><b>Warning:</b></dt><dd>Don't call this function directly, it is only meant to be used as a callback for the hash table.</dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="ght__hash__table_8h.html#a9">ght_fn_hash_t</a> <p>
<a class="el" href="ght__hash__table_8h.html#a29">ght_one_at_a_time_hash()</a>, <a class="el" href="ght__hash__table_8h.html#a30">ght_rotating_hash()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a13" doxytag="ght_hash_table.h::ght_create"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="structght__hash__table__t.html">ght_hash_table_t</a>* ght_create           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">unsigned int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>i_size</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create a new hash table. The number of buckets should be about as big as the number of elements you wish to store in the table for good performance. The number of buckets is rounded to the next higher power of two.<p>
The hash table is created with <code><a class="el" href="ght__hash__table_8h.html#a29">ght_one_at_a_time_hash()</a></code> as hash function, automatic rehashing disabled, <code>malloc()</code> as the memory allocator and no heuristics.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>i_size</em>&nbsp;</td><td>the number of buckets in the hash table. Giving a non-power of two here will round the size up to the next power of two.</td></tr>
  </table>
</dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="ght__hash__table_8h.html#a15">ght_set_hash()</a>, <a class="el" href="ght__hash__table_8h.html#a16">ght_set_heuristics()</a>, <a class="el" href="ght__hash__table_8h.html#a17">ght_set_rehash()</a>, <p>
<a class="el" href="ght__hash__table_8h.html#a14">ght_set_alloc()</a></dd></dl>
<dl compact><dt><b>Returns:</b></dt><dd>a pointer to the hash table or NULL upon error. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a28" doxytag="ght_hash_table.h::ght_finalize"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void ght_finalize           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structght__hash__table__t.html">ght_hash_table_t</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>p_ht</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Free the hash table. <a class="el" href="ght__hash__table_8h.html#a28">ght_finalize()</a> should typically be called at the end of the program. Note that only the metadata and the keys of the table is freed, not the entries. If you want to free the entries when removing the table, the entries will have to be manually freed before <a class="el" href="ght__hash__table_8h.html#a28">ght_finalize()</a> is called like:<p>
<pre>
 ght_iterator_t iterator;
 void *p_key;
 void *p_e;</pre><p>
<pre> for(p_e = ght_first(p_table, &amp;iterator, &amp;p_key); p_e; p_e = ght_next(p_table, &amp;iterator, &amp;p_key))
   {
     free(p_e);
   }</pre><p>
<pre> ght_finalize(p_table);
 </pre><p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>p_ht</em>&nbsp;</td><td>the table to remove. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a25" doxytag="ght_hash_table.h::ght_first"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void* ght_first           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structght__hash__table__t.html">ght_hash_table_t</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>p_ht</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>ght_iterator_t *&nbsp;</td>
          <td class="mdname" nowrap> <em>p_iterator</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>void **&nbsp;</td>
          <td class="mdname" nowrap> <em>pp_key</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return the first entry in the hash table. This function should be used for iteration and is used together with <a class="el" href="ght__hash__table_8h.html#a26">ght_next()</a>. Note that you cannot assume anything about the order in which the entries are accessed. If an entry is inserted during an iteration, the entry might or might not occur in the iteration. Note that removal during an iteration is only safe for the <em>current</em> entry or an entry which has <em>already been iterated over</em>.<p>
The use of the ght_iterator_t allows for several concurrent iterations, where you would use one ght_iterator_t for each iteration. In threaded environments, you should still lock access to the hash table for insertion and removal.<p>
A typical example might look as follows: <pre>
 <a class="el" href="structght__hash__table__t.html">ght_hash_table_t</a> *p_table;
 ght_iterator_t iterator;
 void *p_key;
 void *p_e;</pre><p>
<pre> [Create table etc...]
 for(p_e = ght_first(p_table, &amp;iterator, &amp;p_key); p_e; p_e = ght_next(p_table, &amp;iterator, &amp;p_key))
   {
      [Do something with the current entry p_e and it's key p_key]
   }
 </pre><p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>p_ht</em>&nbsp;</td><td>the hash table to iterate through.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>p_iterator</em>&nbsp;</td><td>the iterator to use. The value of the structure is filled in by this function and may be stack allocated.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pp_key</em>&nbsp;</td><td>a pointer to the pointer of the key (NULL if none).</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>a pointer to the first entry in the table or NULL if there are no entries.</dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="ght__hash__table_8h.html#a26">ght_next()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a23" doxytag="ght_hash_table.h::ght_get"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void* ght_get           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structght__hash__table__t.html">ght_hash_table_t</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>p_ht</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>unsigned int&nbsp;</td>
          <td class="mdname" nowrap> <em>i_key_size</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>p_key_data</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Lookup an entry in the hash table. The entry is <em>not</em> removed from the table.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>p_ht</em>&nbsp;</td><td>the hash table to search in. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>i_key_size</em>&nbsp;</td><td>the size of the key to search with (in bytes). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>p_key_data</em>&nbsp;</td><td>the key to search for.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>a pointer to the found entry or NULL if no entry could be found. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a21" doxytag="ght_hash_table.h::ght_insert"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int ght_insert           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structght__hash__table__t.html">ght_hash_table_t</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>p_ht</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>p_entry_data</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>unsigned int&nbsp;</td>
          <td class="mdname" nowrap> <em>i_key_size</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>p_key_data</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Insert an entry into the hash table. Prior to inserting anything, make sure that the table is created with <a class="el" href="ght__hash__table_8h.html#a13">ght_create()</a>. If an element with the same key as this one already exists in the table, the insertion will fail and -1 is returned.<p>
A typical example is shown below, where the string "blabla" (including the ''-terminator) is used as a key for the integer 15.<p>
<pre>
 <a class="el" href="structght__hash__table__t.html">ght_hash_table_t</a> *p_table;
 char *p_key_data;
 int *p_data;
 int ret;</pre><p>
<pre> [Create p_table etc...]
 p_data = malloc(sizeof(int));
 p_key_data = "blabla";
 *p_data = 15;</pre><p>
<pre> ret = ght_insert(p_table,
                  p_data,
                  sizeof(char)*(strlen(p_key_data)+1), p_key_data);
 </pre><p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>p_ht</em>&nbsp;</td><td>the hash table to insert into. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>p_entry_data</em>&nbsp;</td><td>the data to insert. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>i_key_size</em>&nbsp;</td><td>the size of the key to associate the data with (in bytes). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>p_key_data</em>&nbsp;</td><td>the key to use. The value will be copied, and it is therefore OK to use a stack-allocated entry here.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>0 if the element could be inserted, -1 otherwise. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a26" doxytag="ght_hash_table.h::ght_next"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void* ght_next           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structght__hash__table__t.html">ght_hash_table_t</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>p_ht</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>ght_iterator_t *&nbsp;</td>
          <td class="mdname" nowrap> <em>p_iterator</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>void **&nbsp;</td>
          <td class="mdname" nowrap> <em>pp_key</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return the next entry in the hash table. This function should be used for iteration, and must be called after <a class="el" href="ght__hash__table_8h.html#a25">ght_first()</a>.<p>
<dl compact><dt><b>Warning:</b></dt><dd>calling this without first having called ght_first will give undefined results (probably a crash), since p_iterator isn't filled correctly.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>p_ht</em>&nbsp;</td><td>the hash table to iterate through.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>p_iterator</em>&nbsp;</td><td>the iterator to use.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pp_key</em>&nbsp;</td><td>a pointer to the pointer of the key (NULL if none).</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>a pointer to the next entry in the table or NULL if there are no more entries in the table.</dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="ght__hash__table_8h.html#a25">ght_first()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a29" doxytag="ght_hash_table.h::ght_one_at_a_time_hash"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="ght__hash__table_8h.html#a6">ght_uint32_t</a> ght_one_at_a_time_hash           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structs__hash__key.html">ght_hash_key_t</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>p_key</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
One-at-a-time-hash. One-at-a-time-hash is a good hash function, and is the default when <a class="el" href="ght__hash__table_8h.html#a13">ght_create()</a> is called with NULL as the fn_hash parameter. This was found in a DrDobbs article, see <a href="http://burtleburtle.net/bob/hash/doobs.html">http://burtleburtle.net/bob/hash/doobs.html</a><p>
<dl compact><dt><b>Warning:</b></dt><dd>Don't call this function directly, it is only meant to be used as a callback for the hash table.</dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="ght__hash__table_8h.html#a9">ght_fn_hash_t</a> <p>
<a class="el" href="ght__hash__table_8h.html#a30">ght_rotating_hash()</a>, <a class="el" href="ght__hash__table_8h.html#a31">ght_crc_hash()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a27" doxytag="ght_hash_table.h::ght_rehash"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void ght_rehash           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structght__hash__table__t.html">ght_hash_table_t</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>p_ht</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>unsigned int&nbsp;</td>
          <td class="mdname" nowrap> <em>i_size</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Rehash the hash table.<p>
Rehashing will change the size of the hash table, retaining all elements. This is very costly and should be avoided unless really needed. If <code>GHT_AUTOMATIC_REHASH</code> is specified in the flag parameter when <a class="el" href="ght__hash__table_8h.html#a13">ght_create()</a> is called, the hash table is automatically rehashed when the number of stored elements exceeds two times the number of buckets in the table (making calls to this function unessessary).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>p_ht</em>&nbsp;</td><td>the hash table to rehash. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>i_size</em>&nbsp;</td><td>the new size of the table.</td></tr>
  </table>
</dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="ght__hash__table_8h.html#a13">ght_create()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a24" doxytag="ght_hash_table.h::ght_remove"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void* ght_remove           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structght__hash__table__t.html">ght_hash_table_t</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>p_ht</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>unsigned int&nbsp;</td>
          <td class="mdname" nowrap> <em>i_key_size</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>p_key_data</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Remove an entry from the hash table. The entry is removed from the table, but not freed (that is, the data stored is not freed).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>p_ht</em>&nbsp;</td><td>the hash table to use. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>i_key_size</em>&nbsp;</td><td>the size of the key to search with (in bytes). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>p_key_data</em>&nbsp;</td><td>the key to search for.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>a pointer to the removed entry or NULL if the entry could be found. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a22" doxytag="ght_hash_table.h::ght_replace"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void* ght_replace           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structght__hash__table__t.html">ght_hash_table_t</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>p_ht</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>p_entry_data</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>unsigned int&nbsp;</td>
          <td class="mdname" nowrap> <em>i_key_size</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>p_key_data</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Replace an entry in the hash table. This function will return an error if the entry to be replaced does not exist, i.e. it cannot be used to insert new entries.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>p_ht</em>&nbsp;</td><td>the hash table to search in. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>p_entry_data</em>&nbsp;</td><td>the new data for the key. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>i_key_size</em>&nbsp;</td><td>the size of the key to search with (in bytes). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>p_key_data</em>&nbsp;</td><td>the key to search for.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>a pointer to the <em>old</em> value or NULL if the operation failed. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a30" doxytag="ght_hash_table.h::ght_rotating_hash"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="ght__hash__table_8h.html#a6">ght_uint32_t</a> ght_rotating_hash           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structs__hash__key.html">ght_hash_key_t</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>p_key</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Rotating hash. Not so good hash function. This was found in a DrDobbs article, see <a href="http://burtleburtle.net/bob/hash/doobs.html">http://burtleburtle.net/bob/hash/doobs.html</a><p>
<dl compact><dt><b>Warning:</b></dt><dd>Don't call this function directly, it is only meant to be used as a callback for the hash table.</dd></dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="ght__hash__table_8h.html#a9">ght_fn_hash_t</a> <p>
<a class="el" href="ght__hash__table_8h.html#a29">ght_one_at_a_time_hash()</a>, <a class="el" href="ght__hash__table_8h.html#a31">ght_crc_hash()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a14" doxytag="ght_hash_table.h::ght_set_alloc"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void ght_set_alloc           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structght__hash__table__t.html">ght_hash_table_t</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>p_ht</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="ght__hash__table_8h.html#a10">ght_fn_alloc_t</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>fn_alloc</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="ght__hash__table_8h.html#a11">ght_fn_free_t</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>fn_free</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set the allocation/freeing functions to use for a hash table. The allocation function will only be called when a new entry is inserted.<p>
The allocation size will always be <code>sizeof(ght_hash_entry_t) + sizeof(ght_hash_key_t) + key_size</code>. The actual size varies with the key size.<p>
If this function is <em>not</em> called, <code>malloc()</code> and <code>free()</code> will be used for allocation and freeing.<p>
<dl compact><dt><b>Warning:</b></dt><dd>Always call this function <em>before</em> any entries are inserted into the table. Otherwise, the new free() might be called on something that were allocated with another allocation function.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>p_ht</em>&nbsp;</td><td>the hash table to set the memory management functions for. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fn_alloc</em>&nbsp;</td><td>the allocation function to use. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fn_free</em>&nbsp;</td><td>the deallocation function to use. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a18" doxytag="ght_hash_table.h::ght_set_bounded_buckets"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void ght_set_bounded_buckets           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structght__hash__table__t.html">ght_hash_table_t</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>p_ht</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>unsigned int&nbsp;</td>
          <td class="mdname" nowrap> <em>limit</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>ght_fn_bucket_free_callback_t&nbsp;</td>
          <td class="mdname" nowrap> <em>fn</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Enable or disable bounded buckets.<p>
With bounded buckets, the hash table will act as a cache, only holding a fixed number of elements per bucket. <em>limit</em> specifies the limit of elements per bucket. When inserting elements with <em>ght_insert</em> into a bounded table, the last entry in the bucket chain will be free:d. libghthash will then call the callback function <em>fn</em>, which allow the user of the library to dispose of the key and data.<p>
Bounded buckets are disabled by default.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>p_ht</em>&nbsp;</td><td>the hash table to set the bounded buckets for. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>limit</em>&nbsp;</td><td>the maximum number of items in each bucket. If <em>limit</em> is set to 0, bounded buckets are disabled. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fn</em>&nbsp;</td><td>a pointer to a callback function that is called when an entry is free:d. The function should return 0 if the entry can be freed, or -1 otherwise. If -1 is returned, libghthash will select the second last entry and call the callback with that instead. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a15" doxytag="ght_hash_table.h::ght_set_hash"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void ght_set_hash           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structght__hash__table__t.html">ght_hash_table_t</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>p_ht</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="ght__hash__table_8h.html#a9">ght_fn_hash_t</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>fn_hash</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set the hash function to use for a hash table.<p>
<dl compact><dt><b>Warning:</b></dt><dd>Always call this function before any entries are inserted into the table. Otherwise, it will not be possible to find entries that were inserted before this function was called.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>p_ht</em>&nbsp;</td><td>the hash table set the hash function for. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fn_hash</em>&nbsp;</td><td>the hash function. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a16" doxytag="ght_hash_table.h::ght_set_heuristics"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void ght_set_heuristics           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structght__hash__table__t.html">ght_hash_table_t</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>p_ht</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>i_heuristics</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set the heuristics to use for the hash table. The possible values are:<p>
<ul>
<li><code>GHT_HEURISTICS_NONE</code>: Don't use any heuristics.</li><li><code>0</code>: Same as above.</li><li><code>GHT_HEURISTICS_TRANSPOSE</code>: Use transposing heuristics. An accessed element will move one step up in the bucket-list with this method.</li><li><code>GHT_HEURISTICS_MOVE_TO_FRONT</code>: Use move-to-front heuristics. An accessed element will be moved the front of the bucket list with this method.</li></ul>
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>p_ht</em>&nbsp;</td><td>the hash table set the heuristics for. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>i_heuristics</em>&nbsp;</td><td>the heuristics to use. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a17" doxytag="ght_hash_table.h::ght_set_rehash"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void ght_set_rehash           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structght__hash__table__t.html">ght_hash_table_t</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>p_ht</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>b_rehash</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Enable or disable automatic rehashing.<p>
With automatic rehashing, the table will rehash itself when the number of elements in the table are twice as many as the number of buckets. You should note that automatic rehashing will cause your application to be really slow when the table is rehashing (which might happen at times when you need speed), you should therefore be careful with this in time-constrainted applications.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>p_ht</em>&nbsp;</td><td>the hash table to set rehashing for. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>b_rehash</em>&nbsp;</td><td>TRUE if rehashing should be used or FALSE if it should not be used. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a19" doxytag="ght_hash_table.h::ght_size"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">unsigned int ght_size           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structght__hash__table__t.html">ght_hash_table_t</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>p_ht</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the size (the number of items) of the hash table.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>p_ht</em>&nbsp;</td><td>the hash table to get the size for.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>the number of items in the hash table. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a20" doxytag="ght_hash_table.h::ght_table_size"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">unsigned int ght_table_size           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="structght__hash__table__t.html">ght_hash_table_t</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>p_ht</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the table size (the number of buckets) of the hash table.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>p_ht</em>&nbsp;</td><td>the hash table to get the table size for.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>the number of buckets in the hash table. </dd></dl>
    </td>
  </tr>
</table>
<hr size="1"><address style="align: right;"><small>Generated on Sun Nov 27 10:49:06 2005 for libghthash by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.2 </small></address>
</body>
</html>
